#!/usr/bin/env python3
#
#  Copyright 2002-2022 Barcelona Supercomputing Center (www.bsc.es)
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#

# -*- coding: utf-8 -*-

"""
Process the EAR metrics obtained from a PyCOMPSs application execution.

It generates the plots that show the energy consumed, as well as other metrics
harvested by EAR.
"""

import argparse
import csv
import glob
import typing
import matplotlib.pyplot as plt
import numpy as np


class GenEnergyException(Exception):
    """Generate energy exception."""


def get_lists_of_files():
    """Discover the existing files generated by EAR.

    :return: List of app files and list of loops files.
    """
    app = sorted(glob.glob("./*.time.csv"))
    loops = sorted(glob.glob("./*.time.loops.csv"))
    return app, loops


def load_csv(file_name: str) -> ([], []):
    """Load the given csv file.

    :param file_name: File name to be loaded.
    :return: The file name contents as csv object.
    """
    header = []
    content = []
    with open(file_name, newline="", encoding="utf-8") as csvfile:
        csv_reader = csv.reader(csvfile, delimiter=";", quotechar="|")
        first = True
        for row in csv_reader:
            if first:
                header = row
                first = False
            else:
                content.append(row)
    return header, content


def merge_files(files, result_file):
    """Merge all given files.

    Takes the first one with its header,
    and joins the rest skipping their headers.

    :param files: List of file paths to merge.
    :param result_file: Name of the resulting file.
    :return: None
    """
    # Load all contents
    first = True
    result_contents = []
    for file_name in files:
        header, content = load_csv(file_name)
        if first:
            result_contents.append(";".join(header))
            first = False
        for row in content:
            result_contents.append(";".join(row))
    # Then write all of them into a file
    with open(result_file, "w", encoding="utf-8") as f_d:
        for line in result_contents:
            f_d.write(f"{line}\n")


def generate_average_power(header: [], content: [], result_file: str) -> None:
    """Generate the average power plot (per node).

    :param header: List of elements in header.
    :param content: List of rows (each row is a list of elements).
    :param result_file: File name where to store the plot.
    :result: None
    """
    print("- Generating average power plot.")
    group_by = "NODENAME"
    label_x = "JOBNAME"
    label_y = "DC_NODE_POWER_W"
    xlabel = "Worker node"
    ylabel = "Watts (W)"
    title = "Average Power"
    common_average_plot(
        group_by,
        label_x,
        label_y,
        header,
        content,
        result_file,
        False,
        xlabel,
        ylabel,
        title,
        True,
    )


def generate_average_cpufreq(
    header: [], content: [], result_file: str
) -> None:
    """Generate the average cpufreq plot (per node).

    :param header: List of elements in header.
    :param content: List of rows (each row is a list of elements).
    :param result_file: File name where to store the plot.
    :result: None
    """
    print("- Generating average CPU frequency plot.")
    group_by = "NODENAME"
    label_x = "JOBNAME"
    label_y = "AVG_CPUFREQ_KHZ"
    xlabel = "Worker node"
    ylabel = "Khz"
    title = "Average CPU Frequency"
    common_average_plot(
        group_by,
        label_x,
        label_y,
        header,
        content,
        result_file,
        True,
        xlabel,
        ylabel,
        title,
    )


def generate_accumulated_energy(
    header: [], content: [], result_file: str
) -> None:
    """Generate the accumulated energy plot (per node).

    :param header: List of elements in header.
    :param content: List of rows (each row is a list of elements).
    :param result_file: File name where to store the plot.
    :result: None
    """
    print("- Generating accumulated energy plot.")
    group_by = "NODENAME"
    label_x = "JOBNAME"
    label_y = ["TIME_SEC", "*", "DC_NODE_POWER_W"]
    xlabel = "Worker node"
    ylabel = "Joules (J)"
    title = "Accumulated Energy"
    common_average_plot(
        group_by,
        label_x,
        label_y,
        header,
        content,
        result_file,
        False,
        xlabel,
        ylabel,
        title,
        True
    )


def generate_average_cpi(header: [], content: [], result_file: str) -> None:
    """Generate the average cpi plot (per node).

    :param header: List of elements in header.
    :param content: List of rows (each row is a list of elements).
    :param result_file: File name where to store the plot.
    :return: None
    """
    print("- Generating average CPI plot.")
    group_by = "NODENAME"
    label_x = "JOBNAME"
    label_y = "CPI"
    xlabel = "Worker node"
    ylabel = ""
    title = "Average Cycles per Instruction"
    common_average_plot(
        group_by,
        label_x,
        label_y,
        header,
        content,
        result_file,
        True,
        xlabel,
        ylabel,
        title,
    )


def common_average_plot(  # pylint: disable=R0912,R0913,R0914,R0915
    group_by: str,
    label_x: str,
    label_y: typing.Union[str, list],
    header: [],
    content: [],
    result_file: str,
    average_process: bool,
    xlabel: str,
    ylabel: str,
    title: str,
    show_total: bool = False,
) -> None:
    """Generate a plot with the given parameters.

    :param group_by: Group by metric.
    :param label_x: X axis label metric.
    :param label_y: Y axis label metric.
    :param header: List of headers.
    :param content: List of rows.
    :param result_file: Resulting plot file name.
    :param average_process: If perform the average per process (process).
    :param xlabel: Plot x label.
    :param ylabel: Plot y label.
    :param title: Plot title.
    :param show_total: Show the total value in the image and print it.
    """
    index_group = header.index(group_by)
    index_x = header.index(label_x)
    operator = False
    if isinstance(label_y, str):
        index_y = header.index(label_y)
    elif isinstance(label_y, list):
        # the label_y is a list with [field, operator, field]
        operator = True
    else:
        raise GenEnergyException(
            "Unexpected label_y type. Must be str or list."
        )
    data_group = []
    data_x = []
    data_y = []
    for row in content:
        data_group.append(row[index_group])
        data_x.append(row[index_x])
        if operator:
            # the label_y parameter is a list with an operator
            index_y_a = header.index(label_y[0])
            operation = label_y[1]
            index_y_b = header.index(label_y[2])
            if operation == "*":
                data_y.append(float(row[index_y_a]) * float(row[index_y_b]))
            elif operation == "+":
                data_y.append(float(row[index_y_a]) + float(row[index_y_b]))
            elif operation == "/":
                data_y.append(float(row[index_y_a]) / float(row[index_y_b]))
            else:
                raise GenEnergyException(
                    f"Unexpected operator {operation}. Must be *, + or /."
                )
        else:
            data_y.append(float(row[index_y]))
    nodes_np = np.array(data_group)
    nodes = np.unique(nodes_np)
    zipped = zip(data_group, data_y)
    pairs = list(zipped)
    result = {}
    for node in nodes:
        accum = 0
        num_elems = 0
        for pair in pairs:
            if pair[0] == node:
                accum += pair[1]
                num_elems += 1
        if average_process:
            result[node] = accum / num_elems
        else:
            result[node] = accum
    fig, a_x = plt.subplots()
    a_x.bar(
        result.keys(),
        result.values(),
        width=1,
        edgecolor="white",
        linewidth=0.7,
    )
    a_x.bar_label(
        a_x.containers[0], label_type="edge", color="purple", fontsize=7
    )
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.title(title)
    if show_total:
        total = 0
        for node, value in result.items():
            total += value
        print(f"\t- Total {title} : {total} {ylabel}")
        fig.text(
            0.50,
            0.02,
            f"Total : {total} {ylabel}",
            horizontalalignment="center",
            wrap=False,
            fontsize=18,
        )
        fig.tight_layout(rect=(0, 0.05, 1, 1))
    plt.savefig(result_file)
    # plt.show()


def argument_parser() -> argparse.ArgumentParser:
    """Parse the given arguments.

    :return: Parsed arguments.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-a", "--all-figures", action="store_true", help="Generate all figures"
    )
    args = parser.parse_args()
    return args


def main() -> None:
    """Generate energy metrics.

    :return: None.
    """
    # Get arguments
    args = argument_parser()

    # First, discover all files in the given folder
    app, loops = get_lists_of_files()
    print("Merging energy metrics...")
    print(f"- Found {len(app)} app files.")
    print(f"- Found {len(loops)} loops files.")
    if len(app) == 0 or len(loops) == 0:
        print("Could not generate energy metrics since no files were found.")
        return

    # Second, merge all files in a single file
    app_file_name = "app.csv"
    print(f"- Joining app files... {app_file_name}")
    merge_files(app, app_file_name)
    loops_file_name = "loops.csv"
    print(f"- Joining loop files... {loops_file_name}")
    merge_files(loops, loops_file_name)

    # Third, load the merged files and generate the required plots
    header, content = load_csv("app.csv")
    generate_average_power(header, content, "average_power.png")
    generate_accumulated_energy(header, content, "accumulated_energy.png")
    if args.all_figures:
        generate_average_cpufreq(header, content, "average_cpufreq.png")
        generate_average_cpi(header, content, "average_cpi.png")


if __name__ == "__main__":
    main()
