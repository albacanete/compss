#!/bin/bash

# Retrieve script arguments
NUM_WORKERS=$1                  # Number of container workers
APP_IMAGE_NAME=$2               # Application image name. With username: 'john123/my-app'
ABS_CONTEXT=$3                  # Absolute path where the context dir is located. This must be specified by the app-image provider.
COMPUTING_UNITS=$4
MEMORY=$5
SWARM_MANAGER_IP=$6
CREATION_TIME=$6
MIN_VMS=$7
MAX_VMS=$8
shift 8
RUNCOMPSS_ARGS=$*     # From here on, the typical runcompss parameters you would use
#
# This will include: creating the xml's inside master container, executing runcompss, and shutting down workers.
#
master_command="/bin/bash -c '"
CLOUD="False"
if [ ${MAX_VMS}  -gt 0 ]; then
  CLOUD="True"
fi
# Create project and resources
master_command="${master_command} /opt/COMPSs/Runtime/scripts/system/k8s/generate_k8s_resources.sh $ABS_CONTEXT/resources.xml $NUM_WORKERS $COMPUTING_UNITS $MEMORY $SWARM_MANAGER_IP $APP_IMAGE_NAME $CLOUD $CREATION_TIME ; "
master_command="${master_command} /opt/COMPSs/Runtime/scripts/system/k8s/generate_k8s_project.sh $ABS_CONTEXT/project.xml $NUM_WORKERS $APP_IMAGE_NAME $MIN_VMS $MAX_VMS ; "

# Add their path to the runcompss args
RUNCOMPSS_ARGS=" --resources=\"$ABS_CONTEXT/resources.xml\" $RUNCOMPSS_ARGS"
RUNCOMPSS_ARGS=" --project=\"$ABS_CONTEXT/project.xml\"  $RUNCOMPSS_ARGS"
RUNCOMPSS_ARGS=" --master_name=master $RUNCOMPSS_ARGS"
# Execute the runcompss command itself, from the context directory
master_command="${master_command} cd \"${ABS_CONTEXT}\"; sleep 5 ; /opt/COMPSs/Runtime/scripts/user/runcompss $RUNCOMPSS_ARGS 2>&1; "

# After the execution ends, stop all the workers. This is, stop their sshd
# Concatenating with ; to ALWAYS shutdown nodes even if the above commands fail
for i in $(seq 1 "$NUM_WORKERS"); do
    master_command="${master_command} ssh -o StrictHostKeyChecking=no worker${i} \"pkill sshd\" ;"
done
  
master_command="${master_command} exit 0 '" # Final quotes huehue

#
# Now, we are going to create the Kubernetes Deployments file.
# One deployment for the master with 1 replica,
# and one deployment for workers with NUM_WORKER_CONTAINERS replicas
#
 # Create a Kubernetes Deployment for the master container
  cat <<EOF > "${TMP_DIR}/master-deployment.yml"
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${IMG_NAME_WITHOUT_USERNAME}-master
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ${IMG_NAME_WITHOUT_USERNAME}-master
  template:
    metadata:
      labels:
        app: ${IMG_NAME_WITHOUT_USERNAME}-master
    spec:
      containers:
      - name: master
        image: ${IMAGE_NAME}
        args: ["runcompss"]
        env:
        - name: RUNCOMPSS_ARGS
          value: "${RUNCOMPSS_ARGS}"
        # Add resource limits (CPU and memory)
        resources:
          limits:
            cpu: "${COMPUTING_UNITS}"
            memory: "${MEMORY}Gi"
EOF

    # Create a Kubernetes Service for the master container connection
    cat <<EOF > "${TMP_DIR}/master-service.yml"
apiVersion: v1
kind: Service
metadata:
  name: ${IMG_NAME_WITHOUT_USERNAME}-master
spec:
  selector:
    app: ${IMG_NAME_WITHOUT_USERNAME}-master
  ports:
    - protocol: TCP
      port: 22
      targetPort: 22
  type: ClusterIP
EOF

    # Create a Kubernetes Deployment for worker containers
    cat <<EOF > "${TMP_DIR}/worker-deployment.yml"
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${IMG_NAME_WITHOUT_USERNAME}-worker
spec:
  replicas: ${NUM_WORKER_CONTAINERS}
  selector:
    matchLabels:
      app: ${IMG_NAME_WITHOUT_USERNAME}-worker
  template:
    metadata:
      labels:
        app: ${IMG_NAME_WITHOUT_USERNAME}-worker
    spec:
      containers:
      - name: worker
        image: ${IMAGE_NAME}
        args: ["runcompss"]
        env:
        - name: RUNCOMPSS_ARGS
          value: "${RUNCOMPSS_ARGS}"
        resources:
          limits:
            cpu: "${COMPUTING_UNITS}"
            memory: "${MEMORY}Gi"
EOF
}